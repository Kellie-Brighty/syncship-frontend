rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper: check if the user is authenticated
    function isAuth() {
      return request.auth != null;
    }

    // Helper: check if the user owns the document
    function isOwner(uid) {
      return isAuth() && request.auth.uid == uid;
    }

    // Helper: check if the request is coming from the user's specific remote daemon
    function isDaemonFor(uid) {
      return isAuth() && request.auth.token.email.lower() == ('daemon-' + uid + '@syncship.ink').lower();
    }

    // Users collection — users can only read/write their own doc
    match /users/{userId} {
      allow read, update: if isOwner(userId);
      allow create: if isAuth() && request.auth.uid == userId;
      allow delete: if false;
    }

    // Pending plans — keyed by email. Users can read/delete their own pending plan on signup.
    match /pending_plans/{email} {
      allow read, delete: if isAuth() && request.auth.token.email.lower() == email.lower();
      allow write: if false; // Only writable by webhook via Admin SDK
    }

    // Settings collection — users can manage their personal settings (e.g., GitHub tokens), daemon can read
    match /settings/{userId} {
      allow read: if isOwner(userId) || isDaemonFor(userId);
      allow write: if isOwner(userId);
    }

    // Sites collection — only the owner can CRUD their sites, daemon can update status
    match /sites/{siteId} {
      allow read: if isAuth() && (resource.data.ownerId == request.auth.uid || isDaemonFor(resource.data.ownerId));
      allow create: if isAuth() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isAuth() && (resource.data.ownerId == request.auth.uid || isDaemonFor(resource.data.ownerId));
      allow delete: if isAuth() && resource.data.ownerId == request.auth.uid;
    }

    // Deployments — owner can create and cancel. Daemon handles all other updates.
    match /deployments/{deployId} {
      allow read: if isAuth() && (resource.data.ownerId == request.auth.uid || isDaemonFor(resource.data.ownerId));
      allow create: if isAuth() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isAuth() && resource.data.ownerId == request.auth.uid 
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'completedAt'])
                    && request.resource.data.status == 'canceled';
      allow update: if isDaemonFor(resource.data.ownerId);
      allow delete: if false;
    }

    // Server stats — any authenticated user can read; only the specific daemon can write
    match /serverStats/{serverId} {
      allow read: if isAuth();
      allow write: if isDaemonFor(serverId);
    }
    
    // Daemon status and commands
    match /daemon/{docId} {
      allow read: if isAuth();
      allow write: if isOwner(docId) || isDaemonFor(docId);
    }

    // Deny everything else by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
